name: Generate Threat Hunt Report

on:
  issues:
    types: [labeled]

permissions:
  issues: read
  contents: write
  pull-requests: write

jobs:
  generate-report:
    runs-on: ubuntu-latest
    if: contains(github.event.label.name, 'completed')
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Generate Hunt Report
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const path = require('path');
          
          // Get issue data
          const issue = context.payload.issue;
          const issueNumber = issue.number;
          const issueTitle = issue.title;
          const issueBody = issue.body || '';
          const issueAuthor = issue.user.login;
          const issueCreated = new Date(issue.created_at).toISOString().split('T')[0];
          const issueUpdated = new Date(issue.updated_at).toISOString().split('T')[0];
          
          // Get issue comments
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber
          });
          
          // Determine hunt type from title
          let huntType = 'General';
          if (issueTitle.includes('[HYPOTHESIS-HUNT]')) {
            huntType = 'Hypothesis-Driven';
          } else if (issueTitle.includes('[BASELINE-HUNT]')) {
            huntType = 'Baseline Analysis';
          } else if (issueTitle.includes('[HUNT]')) {
            huntType = 'General Hunt';
          }
          
          // Extract hunt name from title (remove prefix)
          const huntName = issueTitle.replace(/^\[.*?\]\s*/, '').trim();
          
          // Parse issue body to extract key information
          function extractValue(body, fieldName) {
            const regex = new RegExp(`### ${fieldName}\\s*\\n([\\s\\S]*?)(?=\\n### |$)`, 'i');
            const match = body.match(regex);
            return match ? match[1].trim() : 'Not specified';
          }
          
          function extractCheckboxes(body, fieldName) {
            const regex = new RegExp(`### ${fieldName}\\s*\\n([\\s\\S]*?)(?=\\n### |$)`, 'i');
            const match = body.match(regex);
            if (!match) return [];
            
            const checkboxes = match[1].match(/- \[x\] (.+)/g);
            return checkboxes ? checkboxes.map(cb => cb.replace('- [x] ', '').trim()) : [];
          }
          
          function extractDropdown(body, fieldName) {
            const regex = new RegExp(`### ${fieldName}\\s*\\n([^\\n]+)`, 'i');
            const match = body.match(regex);
            return match ? match[1].trim() : 'Not specified';
          }
          
          // Extract common fields
          const priority = extractDropdown(issueBody, 'Hunt Priority') || extractDropdown(issueBody, 'Priority Level');
          const duration = extractDropdown(issueBody, 'Estimated Hunt Duration') || extractDropdown(issueBody, 'Expected Hunt Duration');
          
          // Extract key fields based on hunt type
          let extractedData = {};
          
          if (huntType === 'Hypothesis-Driven') {
            extractedData = {
              hypothesis: extractValue(issueBody, 'Primary Hypothesis Statement'),
              rationale: extractValue(issueBody, 'Hypothesis Rationale'),
              mitreTactics: extractDropdown(issueBody, 'Primary MITRE ATT&CK Tactic'),
              dataSources: extractCheckboxes(issueBody, 'Required Data Sources')
            };
          } else if (huntType === 'Baseline Analysis') {
            extractedData = {
              baselineType: extractDropdown(issueBody, 'Baseline Hunt Type'),
              objective: extractValue(issueBody, 'Baseline Objective'),
              dataSources: extractCheckboxes(issueBody, 'Required Data Sources for Baseline')
            };
          } else {
            extractedData = {
              hypothesis: extractValue(issueBody, 'Hunt Hypothesis'),
              dataSources: extractCheckboxes(issueBody, 'Required Data Sources')
            };
          }
          
          // Format comments for hunter notes
          let hunterNotes = '';
          if (comments.data.length > 0) {
            hunterNotes = comments.data.map(comment => {
              const author = comment.user.login;
              const date = new Date(comment.created_at).toISOString().split('T')[0];
              const body = comment.body;
              return `**${author}** (${date}):\n${body}\n`;
            }).join('\n---\n\n');
          } else {
            hunterNotes = 'No comments were added during the hunt.';
          }

    - name: Create Report File
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          
          // Get data from previous step (simplified for YAML compatibility)
          const issue = context.payload.issue;
          const issueNumber = issue.number;
          const issueTitle = issue.title;
          const issueAuthor = issue.user.login;
          const issueCreated = new Date(issue.created_at).toISOString().split('T')[0];
          const issueUpdated = new Date(issue.updated_at).toISOString().split('T')[0];
          
          // Extract hunt name from title
          const huntName = issueTitle.replace(/^\[.*?\]\s*/, '').trim();
          
          // Get comments
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber
          });
          
          // Format hunter notes
          let hunterNotes = '';
          if (comments.data.length > 0) {
            hunterNotes = comments.data.map(comment => {
              const author = comment.user.login;
              const date = new Date(comment.created_at).toISOString().split('T')[0];
              const body = comment.body;
              return `**${author}** (${date}):\n${body}\n`;
            }).join('\n---\n\n');
          } else {
            hunterNotes = 'No comments were added during the hunt.';
          }
          
          // Create the report content
          const reportLines = [
            `# Threat Hunt Report: ${huntName}`,
            '',
            `**Hunt ID:** TH-${issueCreated.replace(/-/g, '')}-${issueNumber.toString().padStart(3, '0')}`,
            `**Issue Number:** #${issueNumber}`,
            `**Hunt Lead:** ${issueAuthor}`,
            `**Date Created:** ${issueCreated}`,
            `**Date Completed:** ${issueUpdated}`,
            '',
            '---',
            '',
            '## Executive Summary',
            '',
            `This report documents the completion of the "${huntName}" threat hunt, conducted as part of our proactive threat hunting program.`,
            '',
            '## Hunt Details',
            '',
            '### Original Issue Information',
            '',
            '```',
            issue.body || 'No issue body provided.',
            '```',
            '',
            '## Hunter Notes',
            '',
            'The following section contains comments, observations, and notes from the hunting team during the course of this investigation:',
            '',
            hunterNotes,
            '',
            '---',
            '',
            '## Findings & Results',
            '',
            '> **Note:** This section should be manually updated with actual hunt findings, evidence, and conclusions.',
            '',
            '### Key Findings',
            '- [ ] **Finding 1:** [Description of finding]',
            '  - Evidence: [Supporting evidence]',
            '  - Impact: [Assessment of impact]',
            '  - Confidence: [High/Medium/Low]',
            '',
            '### Evidence Collected',
            '- [ ] [Evidence item 1]',
            '- [ ] [Evidence item 2]',
            '',
            '### IOCs Identified',
            '- [ ] **IP Addresses:** [List any malicious IPs]',
            '- [ ] **Domains:** [List any malicious domains]',
            '- [ ] **File Hashes:** [List any malicious file hashes]',
            '',
            '## Conclusions',
            '',
            '### Hunt Assessment',
            '- [ ] **Successful** - Hunt objectives met',
            '- [ ] **Partially Successful** - Some objectives met',
            '- [ ] **Unsuccessful** - Objectives not met',
            '',
            '### Risk Assessment',
            '- [ ] **No Risk Identified** - No malicious activity found',
            '- [ ] **Low Risk** - Minor security gaps',
            '- [ ] **Medium Risk** - Moderate security concerns',
            '- [ ] **High Risk** - Significant security issues',
            '- [ ] **Critical Risk** - Active compromise detected',
            '',
            '## Recommendations & Next Steps',
            '',
            '### Immediate Actions (0-24 hours)',
            '- [ ] [Action item 1]',
            '- [ ] [Action item 2]',
            '',
            '### Short-term Actions (1-7 days)',
            '- [ ] [Action item 1]',
            '- [ ] [Action item 2]',
            '',
            '### Long-term Actions (1+ weeks)',
            '- [ ] [Action item 1]',
            '- [ ] [Action item 2]',
            '',
            '## Detection Improvements',
            '',
            '### New Detection Rules',
            '- [ ] [Rule 1]: [Description]',
            '- [ ] [Rule 2]: [Description]',
            '',
            '### Process Improvements',
            '- [ ] [Process improvement 1]',
            '- [ ] [Process improvement 2]',
            '',
            '## Lessons Learned',
            '',
            '### What Worked Well',
            '- [Effective technique or approach]',
            '',
            '### Areas for Improvement',
            '- [Process improvement needed]',
            '',
            '### Future Hunt Recommendations',
            '- [Suggestion for future hunts]',
            '',
            '## Metrics',
            '',
            '- **Total Hunt Duration:** [X hours/days]',
            '- **Systems Examined:** [X systems]',
            '- **Queries Executed:** [X searches]',
            '',
            '---',
            '',
            `**Report Generated:** ${new Date().toISOString().split('T')[0]}`,
            `**Generated By:** GitHub Action (Threat Hunt Report Generator)`,
            `**Source Issue:** [#${issueNumber}](${issue.html_url})`,
            '',
            `> This report was automatically generated from GitHub Issue #${issueNumber}. Please review and update the Findings, Conclusions, and Recommendations sections with actual hunt results.`
          ];
          
          const reportContent = reportLines.join('\n');
          
          // Create reports directory if it doesn't exist
          const reportsDir = 'hunt-reports';
          if (!fs.existsSync(reportsDir)) {
            fs.mkdirSync(reportsDir, { recursive: true });
          }
          
          // Generate filename
          const sanitizedHuntName = huntName.replace(/[^a-zA-Z0-9-_]/g, '-').toLowerCase();
          const filename = `${reportsDir}/hunt-report-${issueCreated}-${issueNumber}-${sanitizedHuntName}.md`;
          
          // Write the report file
          fs.writeFileSync(filename, reportContent);
          
          console.log(`Generated threat hunt report: ${filename}`);
          
          return { filename, reportContent };

    - name: Commit and Push Report
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add hunt-reports/
        git commit -m "Generate threat hunt report for issue #${{ github.event.issue.number }}: ${{ github.event.issue.title }}" || exit 0
        git push


